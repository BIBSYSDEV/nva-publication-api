plugins{
    id 'nva-publication-api.java-library-conventions'
}

allprojects {
    apply plugin: 'nva-publication-api.java-library-conventions'
}

subprojects {
    // For using DynamoDB locally
    configurations.testImplementation.canBeResolved = true
    task copyNativeDeps(type: Copy) {
        from(configurations.testImplementation) {
            include "*.dylib"
            include "*.so"
            include "*.dll"
        }
        into 'build/dynamodb-local'
    }

    test{
        dependsOn copyNativeDeps
        systemProperty "java.library.path", 'build/dynamodb-local'
    }
}

//For generating one unified coverage report
def getProjectList() {
    // These projects are considered. Replace with a different list as needed.
    subprojects + project
}

task jacocoMerge(type: JacocoMerge) {
    group = LifecycleBasePlugin.VERIFICATION_GROUP
    description = 'Merge the JaCoCo data files from all subprojects into one'
    project.afterEvaluate {
        // do it at the end of the config phase to be sure all information is present
        FileCollection execFiles = project.objects.fileCollection()   // an empty FileCollection
        getProjectList().each { Project subproject ->
            if (subproject.pluginManager.hasPlugin('jacoco')) {
                def testTasks = subproject.tasks.withType(Test)
                dependsOn(testTasks)   // ensure that .exec files are actually present

                testTasks.each { Test task ->
                    // The JacocoTaskExtension is the source of truth for the location of the .exec file.
                    JacocoTaskExtension extension = task.getExtensions().findByType(JacocoTaskExtension.class)
                    if (extension != null) {
                        execFiles.from extension.getDestinationFile()
                    }
                }
            }
        }
        executionData = execFiles
    }
    doFirst {
        // .exec files might be missing if a project has no tests. Filter in execution phase.
        executionData = executionData.filter { it.canRead() }
    }
}

def getReportTasks(JacocoReport pRootTask) {
    getProjectList().collect {
        it.tasks.withType(JacocoReport).findAll { it != pRootTask }
    }.flatten()
}

build{
    dependsOn(jacocoMerge)
}

