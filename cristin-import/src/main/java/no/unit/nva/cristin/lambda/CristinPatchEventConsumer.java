package no.unit.nva.cristin.lambda;

import static no.unit.nva.cristin.patcher.exception.ExceptionHandling.castToCorrectRuntimeException;
import static no.unit.nva.publication.PublicationServiceConfig.defaultDynamoDbClient;
import static no.unit.nva.publication.s3imports.ApplicationConstants.defaultS3Client;
import static no.unit.nva.publication.s3imports.FileImportUtils.timestampToString;
import static nva.commons.core.attempt.Try.attempt;
import com.amazonaws.services.dynamodbv2.AmazonDynamoDB;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.SQSEvent;
import com.amazonaws.services.lambda.runtime.events.SQSEvent.SQSMessage;
import no.unit.nva.commons.json.JsonUtils;
import no.unit.nva.cristin.mapper.NvaPublicationPartOfCristinPublication;
import no.unit.nva.cristin.patcher.CristinPatcher;
import no.unit.nva.cristin.patcher.exception.ParentPublicationException;
import no.unit.nva.cristin.patcher.model.ParentAndChild;
import no.unit.nva.events.models.EventReference;
import no.unit.nva.identifiers.SortableIdentifier;
import no.unit.nva.model.Publication;
import no.unit.nva.publication.s3imports.FileContentsEvent;
import no.unit.nva.publication.s3imports.FileEntriesEventEmitter;
import no.unit.nva.publication.s3imports.ImportResult;
import no.unit.nva.publication.service.impl.ResourceService;
import no.unit.nva.s3.S3Driver;
import nva.commons.apigateway.exceptions.NotFoundException;
import nva.commons.core.JacocoGenerated;
import nva.commons.core.SingletonCollector;
import nva.commons.core.attempt.Failure;
import nva.commons.core.paths.UriWrapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import software.amazon.awssdk.services.s3.S3Client;

/**
 * Accepts messages from SQS queue generated by {@link FileEntriesEventEmitter}.
 */
public class CristinPatchEventConsumer implements RequestHandler<SQSEvent, Void> {

    public static final String INVALID_PARENT_MESSAGE = "Could not retrieve a single valid parent publciation";
    public static final String ERROR_PATCHING_CHILD_PUBLICATION = "Error patching child publication: ";
    private static final Logger logger = LoggerFactory.getLogger(CristinPatchEventConsumer.class);
    public static final String PATCH_ERRORS_PATH = "PATCH_ERRORS";
    public static final String JSON = ".json";
    public static final String PATCH_SUCCESS = "PATCH_SUCCESS";
    private final ResourceService resourceService;
    private final S3Client s3Client;

    @JacocoGenerated
    public CristinPatchEventConsumer() {
        this(defaultDynamoDbClient(), defaultS3Client());
    }

    @JacocoGenerated
    protected CristinPatchEventConsumer(AmazonDynamoDB dynamoDbClient, S3Client s3Client) {
        this(ResourceService.builder().withDynamoDbClient(dynamoDbClient).build(), s3Client);
    }

    public CristinPatchEventConsumer(ResourceService resourceService, S3Client s3Client) {
        this.resourceService = resourceService;
        this.s3Client = s3Client;
    }

    @Override
    public Void handleRequest(SQSEvent input, Context context) {
        input.getRecords().forEach(this::processMessage);
        return null;
    }

    protected ParentAndChild processChild(EventReference input) {
        var eventBody = readEventBody(input);
        return attempt(() -> retrieveChildAndParentPublications(eventBody))
            .map(CristinPatcher::updateChildPublication)
            .map(value -> persistChangesInChild(value, input))
            .orElseThrow(fail -> saveErrorReport(fail, input, eventBody));

    }

    protected ParentAndChild processParent(EventReference input) {
        var eventBody = readEventBody(input);
        return attempt(() -> retrieveChildAndParentPublications(eventBody))
                   .map(CristinPatcher::updateParentPublication)
                   .map(value -> persistChangesInParent(value, input))
                   .orElseThrow(fail -> saveErrorReport(fail, input, eventBody));
    }

    private ParentAndChild persistChangesInParent(ParentAndChild parentAndChild, EventReference input) {
        attempt(() -> resourceService.updatePublication(parentAndChild.getParentPublication()))
            .map(updatedPublication -> storeSuccessReport(updatedPublication,
                                                          parentAndChild.getParentPublication(),
                                                          input))
            .orElseThrow();
        return parentAndChild;
    }

    private ParentAndChild persistChangesInChild(ParentAndChild parentAndChild, EventReference input) {
        attempt(() -> resourceService.updatePublication(parentAndChild.getChildPublication()))
            .map(updatedPublication ->
                     storeSuccessReport(updatedPublication, parentAndChild.getParentPublication(), input))
            .orElseThrow();
        return parentAndChild;
    }

    private Publication storeSuccessReport(
        Publication childPublication,
        Publication parentPublication,
        EventReference input) {
        var successFileUriFileUri = constructSuccessFileUri(childPublication, input);
        var s3Driver = new S3Driver(s3Client, successFileUriFileUri.getUri().getHost());
        var reportContent = new ParentAndChild(childPublication, parentPublication);
        attempt(() ->
            s3Driver.insertFile(successFileUriFileUri.toS3bucketPath(), reportContent.toJsonString()))
            .orElseThrow();
        return childPublication;
    }

    private UriWrapper constructSuccessFileUri(Publication publication, EventReference input) {
        var fileUri = UriWrapper.fromUri(input.getUri());
        var timestamp = input.getTimestamp();
        var bucket = fileUri.getHost();
        return bucket
            .addChild(PATCH_SUCCESS)
            .addChild(timestampToString(timestamp))
            .addChild(publication.getIdentifier() + JSON);
    }

    private void processMessage(SQSMessage message) {
        logger.info("received message: " + message.getBody());
        attempt(() -> getEventReferenceFromBody(message.getBody())).map(this::processChild)
            .toOptional();
        attempt(() -> getEventReferenceFromBody(message.getBody())).map(this::processParent)
            .toOptional();
    }

    private EventReference getEventReferenceFromBody(String body) {
        return attempt(() -> JsonUtils.dtoObjectMapper.readValue(body, EventReference.class)).orElseThrow();
    }

    private RuntimeException saveErrorReport(Failure<ParentAndChild> fail, EventReference input,
                                             NvaPublicationPartOfCristinPublication eventBody) {
        String publicationId = eventBody.getNvaPublicationIdentifier();
        String errorMessage = ERROR_PATCHING_CHILD_PUBLICATION + publicationId;
        logger.error(errorMessage, fail.getException());

        saveReportToS3(fail, eventBody, input);

        return castToCorrectRuntimeException(fail.getException());
    }

    private void saveReportToS3(Failure<ParentAndChild> fail, NvaPublicationPartOfCristinPublication eventBody,
                                EventReference input) {
        var errorFileUri = constructErrorFileUri(eventBody, fail.getException(), input);
        var s3Driver = new S3Driver(s3Client, errorFileUri.getUri().getHost());
        var reportContent = ImportResult.reportFailure(eventBody, fail.getException());
        attempt(() -> s3Driver.insertFile(errorFileUri.toS3bucketPath(), reportContent.toJsonString())).orElseThrow();
    }

    private UriWrapper constructErrorFileUri(NvaPublicationPartOfCristinPublication event,
                                             Exception exception, EventReference input) {
        var fileUri = UriWrapper.fromUri(input.getUri());
        var timestamp = input.getTimestamp();
        var bucket = fileUri.getHost();
        return bucket
                   .addChild(PATCH_ERRORS_PATH)
                   .addChild(timestampToString(timestamp))
                   .addChild(exception.getClass().getSimpleName())
                   .addChild(fileUri.getPath())
                   .addChild(event.getNvaPublicationIdentifier() + JSON);
    }

    private ParentAndChild retrieveChildAndParentPublications(NvaPublicationPartOfCristinPublication eventBody)
        throws NotFoundException {
        logger.info("CONTENTS: " + eventBody.toJsonString());
        var childPublication = getChildPublication(eventBody);
        var parentPublication = getParentPublication(eventBody);
        eventBody.setChildPublication(childPublication);
        eventBody.getPartOf().setParentPublication(parentPublication);
        return new ParentAndChild(childPublication, parentPublication);
    }

    private Publication getChildPublication(
        NvaPublicationPartOfCristinPublication nvaPublicationPartOfCristinPublication) throws NotFoundException {
        return resourceService.getPublicationByIdentifier(
            new SortableIdentifier(nvaPublicationPartOfCristinPublication.getNvaPublicationIdentifier()));
    }

    private Publication getParentPublication(
        NvaPublicationPartOfCristinPublication nvaPublicationPartOfCristinPublication) {
        var parentPublications = resourceService.getPublicationsByCristinIdentifier(
            nvaPublicationPartOfCristinPublication.getPartOf().getCristinId());
        return attempt(() -> parentPublications
                                 .stream()
                                 .collect(SingletonCollector.collect()))
                   .orElseThrow(fail -> new ParentPublicationException(INVALID_PARENT_MESSAGE, fail.getException()));
    }

    private NvaPublicationPartOfCristinPublication readEventBody(EventReference input) {
        var s3Driver = new S3Driver(s3Client, input.extractBucketName());
        var json = s3Driver.readEvent(input.getUri());
        var fileContentsEvent =
            FileContentsEvent.fromJson(json, NvaPublicationPartOfCristinPublication.class);
        return fileContentsEvent.getContents();

    }
}
