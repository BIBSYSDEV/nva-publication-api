package no.unit.nva.cristin.lambda;

import static no.unit.nva.cristin.CristinImportConfig.eventHandlerObjectMapper;
import static no.unit.nva.cristin.lambda.constants.HardcodedValues.SIKT_OWNER;
import static no.unit.nva.cristin.mapper.nva.exceptions.ExceptionHandling.castToCorrectRuntimeException;
import static no.unit.nva.publication.s3imports.ApplicationConstants.MAX_SLEEP_TIME;
import static no.unit.nva.publication.s3imports.FileImportUtils.timestampToString;
import static nva.commons.core.attempt.Try.attempt;
import com.amazonaws.services.dynamodbv2.AmazonDynamoDB;
import com.amazonaws.services.dynamodbv2.AmazonDynamoDBClientBuilder;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.SQSEvent;
import com.amazonaws.services.lambda.runtime.events.SQSEvent.SQSMessage;
import com.fasterxml.jackson.databind.JsonNode;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.Random;
import java.util.UUID;
import java.util.stream.Collectors;
import no.unit.nva.commons.json.JsonUtils;
import no.unit.nva.cristin.mapper.CristinMapper;
import no.unit.nva.cristin.mapper.CristinObject;
import no.unit.nva.cristin.mapper.Identifiable;
import no.unit.nva.cristin.mapper.nva.NviReport;
import no.unit.nva.events.models.EventReference;
import no.unit.nva.model.Publication;
import no.unit.nva.publication.external.services.UriRetriever;
import no.unit.nva.publication.s3imports.ApplicationConstants;
import no.unit.nva.publication.s3imports.FileContentsEvent;
import no.unit.nva.publication.s3imports.FileEntriesEventEmitter;
import no.unit.nva.publication.s3imports.ImportResult;
import no.unit.nva.publication.service.impl.ResourceService;
import no.unit.nva.publication.utils.CristinUnitsUtil;
import no.unit.nva.s3.S3Driver;
import nva.commons.core.Environment;
import nva.commons.core.JacocoGenerated;
import nva.commons.core.attempt.Failure;
import nva.commons.core.attempt.Try;
import nva.commons.core.paths.UnixPath;
import nva.commons.core.paths.UriWrapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import software.amazon.awssdk.http.urlconnection.UrlConnectionHttpClient;
import software.amazon.awssdk.services.s3.S3Client;

/**
 * Accepts messages from SQS queue generated by {@link FileEntriesEventEmitter}.
 */

@SuppressWarnings("PMD.GodClass")
public class CristinEntryEventConsumer
    implements RequestHandler<SQSEvent, List<Publication>> {

    public static final int MAX_EFFORTS = 10;
    public static final String ERROR_SAVING_CRISTIN_RESULT = "Could not save cristin result with ID: ";
    public static final Random RANDOM = new Random(System.currentTimeMillis());
    public static final String EVENT_SUBTOPIC = "PublicationService.CristinData.DataEntry";
    public static final String JSON = ".json";
    public static final String UNKNOWN_CRISTIN_ID_ERROR_REPORT_PREFIX = "unknownCristinId_";
    public static final String DO_NOT_WRITE_ID_IN_EXCEPTION_MESSAGE = null;
    public static final UnixPath ERRORS_FOLDER = UnixPath.of("errors");
    public static final UnixPath SUCCESS_FOLDER = UnixPath.of("SUCCESS");
    public static final UnixPath UPDATE_FOLDER = UnixPath.of("UPDATE");
    public static final UnixPath NVI_FOLDER = UnixPath.of("NVI");
    private static final Logger logger = LoggerFactory.getLogger(CristinEntryEventConsumer.class);
    private static final String PUBLICATIONS_THAT_ARE_PART_OF_OTHER_PUBLICATIONS_BUCKET_PATH =
        "PUBLICATIONS_THAT_ARE_PART_OF_OTHER_PUBLICATIONS";
    public static final String UNITS_S3_OBJECT_URI_ENV = "CRISTIN_UNITS_S3_OBJECT_URI";

    private final ResourceService resourceService;
    private final S3Client s3Client;
    private final DoiDuplicateChecker doiDuplicateChecker;
    private final CristinUnitsUtil cristinUnitsUtil;

    @JacocoGenerated
    public CristinEntryEventConsumer() {
        this(ResourceService.builder().withDynamoDbClient(defaultDynamoDbClient()).build(),
             defaultS3Client(),
             defaultDoiDuplicateChecker(),
             new CristinUnitsUtil(S3Client.create(), new Environment().readEnv(UNITS_S3_OBJECT_URI_ENV)));
    }

    protected CristinEntryEventConsumer(ResourceService resourceService,
                                        S3Client s3Client,
                                        DoiDuplicateChecker doiDuplicateChecker,
                                        CristinUnitsUtil cristinUnitsUtil) {
        this.resourceService = resourceService;
        this.s3Client = s3Client;
        this.doiDuplicateChecker = doiDuplicateChecker;
        this.cristinUnitsUtil = cristinUnitsUtil;
    }

    @Override
    public List<Publication> handleRequest(SQSEvent event, Context context) {
        return event.getRecords()
                   .stream()
                   .map(this::processMessage)
                   .flatMap(Optional::stream)
                   .collect(Collectors.toList());
    }

    @JacocoGenerated
    private static S3Client defaultS3Client() {
        return S3Client.builder()
                   .httpClient(UrlConnectionHttpClient.create())
                   .build();
    }

    @JacocoGenerated
    private static DoiDuplicateChecker defaultDoiDuplicateChecker() {
        return new DoiDuplicateChecker(defaultUriRetriever(), new Environment().readEnv("API_HOST"));
    }

    @JacocoGenerated
    private static AmazonDynamoDB defaultDynamoDbClient() {
        return AmazonDynamoDBClientBuilder
                   .standard()
                   .withRegion(ApplicationConstants.AWS_REGION.id())
                   .build();
    }

    @JacocoGenerated
    private static UriRetriever defaultUriRetriever() {
        return new UriRetriever();
    }

    private Optional<Publication> processMessage(SQSMessage message) {
        logger.info("received message: " + message.getBody());
        return attempt(() -> getEventReferenceFromBody(message.getBody())).map(this::processEvent)
                   .toOptional();
    }

    private Publication processEvent(EventReference eventReference) {
        var eventBody = readEventBody(eventReference);
        return attempt(() -> parseCristinObject(eventBody))
                   .map(cristinObject -> generatePublicationRepresentations(cristinObject, eventBody))
                   .map(this::upsertPublication)
                   .orElseThrow(fail -> handleSavingError(fail, eventBody, eventReference));

    }

    private Publication upsertPublication(PublicationRepresentations publicationRepresentation) {
        return publicationAlreadyExists(publicationRepresentation)
                   ? performUpdate(publicationRepresentation)
                   : createNew(publicationRepresentation);
    }

    private Publication createNew(PublicationRepresentations publicationRepresentation) {
        return attempt(() -> publicationRepresentation)
            .map(doiDuplicateChecker::throwIfDoiExists)
             .map(this::persistNvaPublicationInDatabaseAndGetUpdatedPublicationIdentifier)
             .map(this::persistConversionReports)
             .orElseThrow();
    }

    private Publication performUpdate(PublicationRepresentations publicationRepresentation) {
        return attempt(() -> getExistingPublication(publicationRepresentation))
                   .map(publicationRepresentation::withExistingPublication)
                   .map(PublicationUpdater::update)
                   .map(this::persistUpdatedPublication)
                   .map(this::persistUpdateReport)
                   .orElseThrow();
    }

    private PublicationRepresentations persistUpdatedPublication(
        PublicationRepresentations publicationRepresentations) {
        resourceService.updatePublication(publicationRepresentations.getExistingPublication());
        return publicationRepresentations;
    }

    private Publication persistUpdateReport(PublicationRepresentations publicationRepresentations) {
        var fileUri = constructUpdateFileUri(publicationRepresentations);
        var s3Driver = new S3Driver(s3Client, fileUri.getUri().getHost());
        var content = publicationRepresentations.toString();
        attempt(() -> s3Driver.insertFile(fileUri.toS3bucketPath(),
                                          content)).orElseThrow();
        return publicationRepresentations.getExistingPublication();
    }

    private Publication getExistingPublication(PublicationRepresentations publicationRepresentation) {
        var cristinIdentifier = publicationRepresentation.getCristinObject().getId().toString();
        return resourceService.getPublicationsByCristinIdentifier(cristinIdentifier).getFirst();
    }

    private boolean publicationAlreadyExists(PublicationRepresentations publicationRepresentations) {
        var cristinIdentifier = publicationRepresentations.getCristinObject().getId().toString();
        var publicationByCristinIdentifier = resourceService.getPublicationsByCristinIdentifier(cristinIdentifier);
        return !publicationByCristinIdentifier.isEmpty();
    }

    private EventReference getEventReferenceFromBody(String body) {
        return attempt(() -> JsonUtils.dtoObjectMapper.readValue(body, EventReference.class)).orElseThrow();
    }

    private Publication persistConversionReports(PublicationRepresentations publicationRepresentations) {
        persistCristinIdentifierInFileNamedWithPublicationIdentifier(publicationRepresentations);
        persistPartOfCristinIdentifierIfPartOfExists(publicationRepresentations);
        persistNviReportIfNeeded(publicationRepresentations);
        return publicationRepresentations.getIncomingPublication();
    }

    private void persistNviReportIfNeeded(PublicationRepresentations publicationRepresentations) {
        if (hasScientificResource(publicationRepresentations)) {
            var nviReport = NviReport.fromPublicationRepresentation(publicationRepresentations);
            saveNviReport(publicationRepresentations, nviReport);
        }
    }

    private static boolean hasScientificResource(PublicationRepresentations publicationRepresentations) {
        return Optional.ofNullable(publicationRepresentations.getCristinObject())
                   .map(CristinObject::getScientificResources)
                   .map(list -> !list.isEmpty())
                   .orElse(false);
    }

    private void saveNviReport(PublicationRepresentations publicationRepresentations, NviReport nviReport) {
        var fileUri = constructNviReportUri(publicationRepresentations);
        var s3Driver = new S3Driver(s3Client, fileUri.getUri().getHost());
        attempt(() -> s3Driver.insertFile(fileUri.toS3bucketPath(), nviReport.toJsonString())).orElseThrow();
    }

    private PublicationRepresentations generatePublicationRepresentations(
        CristinObject cristinObject,
        FileContentsEvent<JsonNode> eventBody) {
        var publication = new CristinMapper(cristinObject, cristinUnitsUtil, s3Client).generatePublication();
        return new PublicationRepresentations(cristinObject, publication, eventBody);
    }

    private void persistPartOfCristinIdentifierIfPartOfExists(
        PublicationRepresentations publicationRepresentations) {
        if (publicationRepresentations.cristinObjectIsPartOfAnotherPublication()) {
            persistPartOfCristinIdentifierWithPublicationId(publicationRepresentations);
        }
    }

    private void persistPartOfCristinIdentifierWithPublicationId(
        PublicationRepresentations publicationRepresentations) {
        var partOf = publicationRepresentations.getPartOf();
        var fileUri = constructPartOfFileUri(publicationRepresentations);
        var s3Driver = new S3Driver(s3Client, fileUri.getUri().getHost());
        attempt(() -> s3Driver.insertFile(fileUri.toS3bucketPath(), partOf.toJsonString())).orElseThrow();
    }

    private void persistCristinIdentifierInFileNamedWithPublicationIdentifier(
        PublicationRepresentations publicationRepresentations) {
        var cristinIdentifier = publicationRepresentations.getCristinIdentifier();
        var fileUri = constructSuccessFileUri(publicationRepresentations);
        var s3Driver = new S3Driver(s3Client, fileUri.getUri().getHost());
        attempt(() -> s3Driver.insertFile(fileUri.toS3bucketPath(),
                                          cristinIdentifier)).orElseThrow();
    }

    private UriWrapper constructPartOfFileUri(PublicationRepresentations publicationRepresentations) {
        var publicationIdentifier = publicationRepresentations.getNvaPublicationIdentifier();
        var eventBodyFileUri = publicationRepresentations.getOriginalEventFileUri();
        var fileUri = UriWrapper.fromUri(eventBodyFileUri);
        var timestamp = publicationRepresentations.getOriginalTimeStamp();
        var bucket = fileUri.getHost();
        return bucket
                   .addChild(PUBLICATIONS_THAT_ARE_PART_OF_OTHER_PUBLICATIONS_BUCKET_PATH)
                   .addChild(timestampToString(timestamp))
                   .addChild(publicationIdentifier);
    }

    private UriWrapper constructSuccessFileUri(PublicationRepresentations publicationRepresentations) {
        var publicationIdentifier = publicationRepresentations.getNvaPublicationIdentifier();
        var eventBodyFileUri = publicationRepresentations.getOriginalEventFileUri();
        var timestamp = publicationRepresentations.getOriginalTimeStamp();
        var fileUri = UriWrapper.fromUri(eventBodyFileUri);
        var bucket = fileUri.getHost();
        return bucket
                   .addChild(SUCCESS_FOLDER)
                   .addChild(timestampToString(timestamp))
                   .addChild(publicationIdentifier);
    }

    private UriWrapper constructUpdateFileUri(PublicationRepresentations publicationRepresentations) {
        var publicationIdentifier = publicationRepresentations.getExistingPublication().getIdentifier().toString();
        var eventBodyFileUri = publicationRepresentations.getOriginalEventFileUri();
        var timestamp = publicationRepresentations.getOriginalTimeStamp();
        var fileUri = UriWrapper.fromUri(eventBodyFileUri);
        var bucket = fileUri.getHost();
        return bucket.addChild(UPDATE_FOLDER).addChild(publicationIdentifier);
    }

    private UriWrapper constructNviReportUri(PublicationRepresentations publicationRepresentations) {
        var publicationIdentifier = publicationRepresentations.getNvaPublicationIdentifier();
        var eventBodyFileUri = publicationRepresentations.getOriginalEventFileUri();
        var timestamp = publicationRepresentations.getOriginalTimeStamp();
        var fileUri = UriWrapper.fromUri(eventBodyFileUri);
        var bucket = fileUri.getHost();
        return bucket
                   .addChild(NVI_FOLDER)
                   .addChild(timestampToString(timestamp))
                   .addChild(publicationIdentifier);
    }

    private FileContentsEvent<JsonNode> readEventBody(EventReference input) {
        var s3Driver = new S3Driver(s3Client, input.extractBucketName());
        var json = s3Driver.readEvent(input.getUri());
        return FileContentsEvent.fromJson(json, JsonNode.class);
    }

    private CristinObject parseCristinObject(FileContentsEvent<JsonNode> eventBody) {
        CristinObject cristinObject = jsonNodeToCristinObject(eventBody);
        cristinObject.hardcodePublicationOwner(SIKT_OWNER);
        return cristinObject;
    }

    private Identifiable parseIdentifiableObject(FileContentsEvent<JsonNode> event) {
        return attempt(event::getContents)
                   .map(jsonNode -> eventHandlerObjectMapper.convertValue(jsonNode, Identifiable.class))
                   .orElseThrow();
    }

    private CristinObject jsonNodeToCristinObject(FileContentsEvent<JsonNode> event) {
        return attempt(event::getContents)
                   .map(CristinObject::fromJson)
                   .orElseThrow();
    }

    private PublicationRepresentations persistNvaPublicationInDatabaseAndGetUpdatedPublicationIdentifier(
        PublicationRepresentations publicationRepresentations) {
        var publicationWithIdentifier =
            persistInDatabase(publicationRepresentations.getIncomingPublication()).orElseThrow();
        publicationRepresentations.setIncomingPublication(publicationWithIdentifier);
        return publicationRepresentations;
    }

    private Try<Publication> persistInDatabase(Publication publication) {
        Try<Publication> attemptSave = tryPersistingInDatabase(publication);

        for (int efforts = 0; shouldTryAgain(attemptSave, efforts); efforts++) {
            attemptSave = tryPersistingInDatabase(publication);

            avoidCongestionInDatabase();
        }
        return attemptSave;
    }

    private boolean shouldTryAgain(Try<Publication> attemptSave, int efforts) {
        return attemptSave.isFailure() && efforts < MAX_EFFORTS;
    }

    private Try<Publication> tryPersistingInDatabase(Publication publication) {
        return attempt(() -> createPublication(publication));
    }

    private Publication createPublication(Publication publication) {
        return resourceService.createPublicationFromImportedEntry(publication);
    }

    private void avoidCongestionInDatabase() {
        int sleepTime = spreadWriteRequests();
        try {
            Thread.sleep(sleepTime);
        } catch (InterruptedException exception) {
            Thread.currentThread().interrupt();
            throw new RuntimeException(exception);
        }
    }

    // Randomize waiting time to avoiding creating parallel executions that perform retries in sync.
    private int spreadWriteRequests() {
        return RANDOM.nextInt(MAX_SLEEP_TIME);
    }

    private RuntimeException handleSavingError(Failure<Publication> fail,
                                               FileContentsEvent<JsonNode> eventBody,
                                               EventReference eventReference) {
        String cristinObjectId = extractCristinObjectId(eventBody).orElse(DO_NOT_WRITE_ID_IN_EXCEPTION_MESSAGE);
        String errorMessage = ERROR_SAVING_CRISTIN_RESULT + cristinObjectId;
        logger.error(errorMessage, fail.getException());
        var updatedBody = mergeEventReferenceAndFileContents(eventBody, eventReference);
        saveReportToS3(fail, updatedBody);
        return castToCorrectRuntimeException(fail.getException());
    }

    private FileContentsEvent<JsonNode> mergeEventReferenceAndFileContents(
        final FileContentsEvent<JsonNode> eventBody,
        final EventReference eventReference) {
        return new FileContentsEvent<>(eventReference.getTopic(),
                                       eventReference.getSubtopic(),
                                       eventReference.getUri(),
                                       eventReference.getTimestamp(),
                                       eventBody.getContents());
    }

    private void saveReportToS3(Failure<Publication> fail,
                                FileContentsEvent<JsonNode> event) {
        var errorFileUri = constructErrorFileUri(event, fail.getException());
        var s3Driver = new S3Driver(s3Client, errorFileUri.getUri().getHost());
        var reportContent = ImportResult.reportFailure(event, fail.getException());
        attempt(() -> s3Driver.insertFile(errorFileUri.toS3bucketPath(), reportContent.toJsonString())).orElseThrow();
    }

    private UriWrapper constructErrorFileUri(FileContentsEvent<JsonNode> event,
                                             Exception exception) {
        var fileUri = UriWrapper.fromUri(event.getFileUri());
        var bucket = fileUri.getHost();
        return bucket
                   .addChild(ERRORS_FOLDER)
                   .addChild(exception.getClass().getSimpleName())
                   .addChild(createErrorReportFilename(event));
    }

    private String createErrorReportFilename(FileContentsEvent<JsonNode> eventBody) {
        return extractCristinObjectId(eventBody)
                   .map(idString -> idString + JSON)
                   .orElseGet(this::unknownCristinIdReportFilename);
    }

    private Optional<String> extractCristinObjectId(FileContentsEvent<JsonNode> event) {
        return attempt(() -> parseIdentifiableObject(event))
                   .map(Identifiable::getId)
                   .toOptional()
                   .map(Objects::toString);
    }

    private String unknownCristinIdReportFilename() {
        return UNKNOWN_CRISTIN_ID_ERROR_REPORT_PREFIX + UUID.randomUUID() + JSON;
    }
}
