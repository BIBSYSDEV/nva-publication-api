package no.unit.nva.doi;

import static java.util.Objects.nonNull;
import static no.unit.nva.doi.LandingPageUtil.LANDING_PAGE_UTIL;
import static nva.commons.core.attempt.Try.attempt;
import java.net.URI;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import no.unit.nva.commons.json.JsonUtils;
import no.unit.nva.doi.model.Customer;
import no.unit.nva.identifiers.SortableIdentifier;
import no.unit.nva.model.Contributor;
import no.unit.nva.model.EntityDescription;
import no.unit.nva.model.Organization;
import no.unit.nva.model.Publication;
import no.unit.nva.model.PublicationDate;
import no.unit.nva.model.Reference;
import no.unit.nva.model.instancetypes.PublicationInstance;
import no.unit.nva.publication.external.services.RawContentRetriever;
import no.unit.nva.transformer.dto.AlternateIdentifierDto;
import no.unit.nva.transformer.dto.CreatorDto;
import no.unit.nva.transformer.dto.DataCiteMetadataDto;
import no.unit.nva.transformer.dto.IdentifierDto;
import no.unit.nva.transformer.dto.IdentifierType;
import no.unit.nva.transformer.dto.PublisherDto;
import no.unit.nva.transformer.dto.ResourceTypeDto;
import no.unit.nva.transformer.dto.TitleDto;

/**
 * DataCiteMetadataDtoMapper is mapping event sources (ie {@link Publication}) into a {@link DataCiteMetadataDto}.
 *
 * <p>{@link DataCiteMetadataDto} is the root object generated by JAXB from DataCite XML Schema for Metadata,
 * which is the required input for {@link no.unit.nva.transformer.Transformer}.
 */
public final class DataCiteMetadataDtoMapper {

    public static final String APPLICATION_LD_JSON = "application/ld+json";

    private DataCiteMetadataDtoMapper() {
    }

    /**
     * Maps a Publication to DataCiteMetadataDto. For use in the nva doi partner data Transformer.
     *
     * @param publication publication
     * @return DataCiteMetadataDto
     */
    public static DataCiteMetadataDto fromPublication(Publication publication, RawContentRetriever uriRetriever) {
        return new DataCiteMetadataDto.Builder()
                   .withCreator(toCreatorDtoList(extractContributors(publication)))
                   .withIdentifier(toIdentifierDto(publication))
                   .withAlternateIdentifiers(extractAlternateIdentifiers(publication))
                   .withPublicationYear(extractPublicationYear(publication))
                   .withPublisher(extractPublisher(publication, uriRetriever))
                   .withTitle(extractTitle(publication))
                   .withResourceType(toResourceTypeDto(publication))
                   .build();
    }

    private static List<AlternateIdentifierDto> extractAlternateIdentifiers(Publication publication) {
        return nonNull(publication) && nonNull(publication.getDoi())
                   ? createAlternateIdentifierFromPublicationIdentifier(publication)
                   : null;
    }

    private static List<AlternateIdentifierDto> createAlternateIdentifierFromPublicationIdentifier(
        Publication publication) {
        return List.of(new AlternateIdentifierDto.Builder()
                           .withValue(LANDING_PAGE_UTIL.constructResourceUri(publication.getIdentifier().toString())
                                          .toString())
                           .build());
    }

    private static List<Contributor> extractContributors(Publication publication) {
        return getEntityDescription(publication)
                   .map(EntityDescription::getContributors)
                   .orElse(null);
    }

    private static String extractPublicationYear(Publication publication) {
        return getEntityDescription(publication)
                   .map(EntityDescription::getPublicationDate)
                   .map(PublicationDate::getYear)
                   .orElse(null);
    }

    private static ResourceTypeDto toResourceTypeDto(Publication publication) {
        return getEntityDescription(publication)
                   .map(EntityDescription::getReference)
                   .map(Reference::getPublicationInstance)
                   .map(PublicationInstance::getInstanceType)
                   .map(DataCiteMetadataDtoMapper::newResourceTypeDto)
                   .orElse(null);
    }

    private static ResourceTypeDto newResourceTypeDto(String resourceType) {
        return new ResourceTypeDto.Builder()
                   .withValue(resourceType)
                   .build();
    }

    private static TitleDto extractTitle(Publication publication) {
        return getEntityDescription(publication)
                   .map(EntityDescription::getMainTitle)
                   .map(title -> new TitleDto.Builder().withValue(title).build())
                   .orElse(null);
    }

    private static Optional<EntityDescription> getEntityDescription(Publication publication) {
        return Optional.of(publication)
                   .map(Publication::getEntityDescription);
    }

    private static PublisherDto extractPublisher(Publication publication, RawContentRetriever uriRetriever) {
        return Optional.of(publication)
                   .map(Publication::getPublisher)
                   .map(Organization::getId)
                   .map(id -> toName(id, uriRetriever))
                   .map(DataCiteMetadataDtoMapper::newPublisherDto)
                   .orElse(null);
    }

    private static String toName(URI id, RawContentRetriever uriRetriever) {
        return Optional.of(uriRetriever)
                   .flatMap(retriever -> retriever.getRawContent(id, APPLICATION_LD_JSON))
                   .map(DataCiteMetadataDtoMapper::toCustomerName)
                   .orElse(null);
    }

    private static String toCustomerName(String body) {
        return attempt(() -> JsonUtils.dtoObjectMapper.readValue(body, Customer.class)).orElseThrow().getName();
    }

    private static PublisherDto newPublisherDto(String customerName) {
        return new PublisherDto.Builder().withValue(customerName).build();
    }

    private static IdentifierDto toIdentifierDto(Publication publication) {
        return nonNull(publication) && nonNull(publication.getDoi())
                   ? createIdentifierDtoFromDoi(publication.getDoi())
                   : getIdentifierDtoFromPublicationIdentifier(publication);
    }

    private static IdentifierDto getIdentifierDtoFromPublicationIdentifier(Publication publication) {
        return Optional.of(publication)
                   .map(Publication::getIdentifier)
                   .map(SortableIdentifier::toString)
                   .map(LANDING_PAGE_UTIL::constructResourceUri)
                   .map(URI::toString)
                   .map(uriString -> new IdentifierDto.Builder()
                                         .withType(IdentifierType.URL)
                                         .withValue(uriString)
                                         .build())
                   .orElse(null);
    }

    private static IdentifierDto createIdentifierDtoFromDoi(URI doi) {
        return new IdentifierDto.Builder().withType(IdentifierType.DOI).withValue(doi.toString()).build();
    }

    private static List<CreatorDto> toCreatorDtoList(List<Contributor> contributors) {
        if (contributors == null) {
            return null;
        }
        return contributors.stream()
                   .map(DataCiteMetadataDtoMapper::toCreatorDto)
                   .collect(Collectors.toList());
    }

    private static CreatorDto toCreatorDto(Contributor contributor) {
        return new CreatorDto.Builder()
                   .withCreatorName(contributor.getIdentity().getName())
                   .build();
    }
}
